{"searchDocs":[{"title":"Typechecking","type":0,"sectionRef":"#","url":"/Oxomo-Coding-Conventions/docs/typechecking","content":"Typechecking Typecheck a reasonable amount; nobody should guess if &quot;Value&quot; is a number, string, or table. Overtyping is still annoying. Bad example: for _, value in Array do --... end Good example: for _, value : number in Array do --... end info Typechecking, by these conventions, is done mostly for autofill purposes. Make sure that you can autofill everything. That beind said, it's also helpful to attach types to arguments and more, especially if the declaration of it didn't already have the type attached. Types should be exported from modules when they represent data that is usable from outside the module. Additionally, making modules exclusively for storing types is recommended when creating complex libraries or systems.","keywords":"","version":"Next"},{"title":"Intro","type":0,"sectionRef":"#","url":"/Oxomo-Coding-Conventions/docs/intro","content":"","keywords":"","version":"Next"},{"title":"Additional notes​","type":1,"pageTitle":"Intro","url":"/Oxomo-Coding-Conventions/docs/intro#additional-notes","content":" Consider the following in addition to the rest of the conventions, as general advice:  Keep code to reasonable minimum.Do not obfuscate or keep statements on single lines.Do not overwrite code.Do not repeat yourself.Do not cache inline functions, such as those from the math or cframe libraries, for example. Luau includes inline caching.Assign variables to the smallest possible scope.Return in a function as soon as possible. ","version":"Next","tagName":"h2"},{"title":"Tables","type":0,"sectionRef":"#","url":"/Oxomo-Coding-Conventions/docs/tables","content":"","keywords":"","version":"Next"},{"title":"Sealed vs Unsealed Tables​","type":1,"pageTitle":"Tables","url":"/Oxomo-Coding-Conventions/docs/tables#sealed-vs-unsealed-tables","content":" Sealed tables are reserved for constants such as configurations or settings.  Modules, classes, etc are all to be declared and mutated in an unsealed table.  ","version":"Next","tagName":"h2"},{"title":"Writing and Reading Tables​","type":1,"pageTitle":"Tables","url":"/Oxomo-Coding-Conventions/docs/tables#writing-and-reading-tables","content":" Use plain key syntax for writing dictionaries when possible, but if there are any entries that cannot follow that, then use [&quot;key&quot;] syntax.  Use dot (table.value) notation for accessing values in a dictionary table when possible (as opposed to something like table[&quot;value&quot;]). ","version":"Next","tagName":"h2"},{"title":"Assertion and Logging","type":0,"sectionRef":"#","url":"/Oxomo-Coding-Conventions/docs/assertion-and-logging","content":"","keywords":"","version":"Next"},{"title":"String Concatenation​","type":1,"pageTitle":"Assertion and Logging","url":"/Oxomo-Coding-Conventions/docs/assertion-and-logging#string-concatenation","content":" When concatenating a string, including for output, make sure to build literal strings with &quot;`&quot;. For example:  local MyNumber = 5 local MyString = `Number = {MyNumber}`   ","version":"Next","tagName":"h2"},{"title":"Printing​","type":1,"pageTitle":"Assertion and Logging","url":"/Oxomo-Coding-Conventions/docs/assertion-and-logging#printing","content":" Reserve printing for the following situations:  DebuggingCritical state changeCritical action  ","version":"Next","tagName":"h2"},{"title":"Warning​","type":1,"pageTitle":"Assertion and Logging","url":"/Oxomo-Coding-Conventions/docs/assertion-and-logging#warning","content":" A warning should always act similar to an error, but of course without breaking the code. Warnings are great for when you have a point of return or default in something. When warning, if it's not already there, make sure to provide a traceback so that the developer can find the issue.  warn(`My warning! {debug.traceback()}`)   ","version":"Next","tagName":"h2"},{"title":"Error​","type":1,"pageTitle":"Assertion and Logging","url":"/Oxomo-Coding-Conventions/docs/assertion-and-logging#error","content":" Errors are served only for unreturnable states of failure. In other words, if you've reached a point where you cannot allow the script to function no matter what, throw an error. It's better to have custom errors than ones thrown by Roblox.  Errors can also be used for assertion, such as types or values in function parameters. ","version":"Next","tagName":"h2"},{"title":"Whitespace","type":0,"sectionRef":"#","url":"/Oxomo-Coding-Conventions/docs/whitespace","content":"","keywords":"","version":"Next"},{"title":"Indentation​","type":1,"pageTitle":"Whitespace","url":"/Oxomo-Coding-Conventions/docs/whitespace#indentation","content":" Indentation is always done with tabs, not spaces.  If you cannot tab, use 4 spaces.  do do do -- Good indentation end end end   Do not use unneeded indentation, and maintain indentation so that it matches the scope in best possible way.  ","version":"Next","tagName":"h2"},{"title":"Line breaks​","type":1,"pageTitle":"Whitespace","url":"/Oxomo-Coding-Conventions/docs/whitespace#line-breaks","content":" Separate different sections of userdata and more with line breaks, as shown in juxtaposition.  The rule of thumb is to always prefer a line break when programming anything if it means your code becomes more readable (just don't be excessive about it). ","version":"Next","tagName":"h2"},{"title":"Userdata Declaration","type":0,"sectionRef":"#","url":"/Oxomo-Coding-Conventions/docs/userdata-declaration","content":"Userdata Declaration Always use the local keyword within any scope, including the top one. Functions have function syntax, variables have variable syntax. When defining functions, put local function before the name, not after. Foo = 5 -- Bad local Foo = 5 -- Good function Bar() -- Bad end local Bar = function() -- Bad end local function Bar() -- Good end ","keywords":"","version":"Next"},{"title":"Documentation","type":0,"sectionRef":"#","url":"/Oxomo-Coding-Conventions/docs/documentation","content":"Documentation All documentation in a codebase should be in Moonwave format, which is very readable and able to be auto-compiled to a generated documenation website. Moonwave as a tool for generating doc websites is separate from your codebase; you can learn about it here: https://eryn.io/moonwave/. This page covers the documentation format, not the page generation tool. Documentation should be written in Moonwave format for the following: High-level modules (ones that are used across the game, not a random sub-module)Open-sourced modulesModules that are critical for functionality When writing Moonwave comments, use comment blocks by starting with --[=[ and ending with ]=]. For example: --[=[ This is a class written in Moonwave format @class ClassName ]=] Also when writing Moonwave comments, opt to always use @param, @class, and @return tags when applicable, and make sure to describe parameters and return data. Anything else is optional but nice to have. When writing a description for a function, make sure to include a Luau snippet. For example: --[=[ Thing that does thing. ```lua Module:DoThing(5) `` @param foo number -- The parameter that does thing ]=] function Module:DoThing(foo : number) --... end Also, be sure to sprinkle normal comments made with -- around your code, especially in parts that are hard to understand without further context. If a developer wouldn't be able to understand something, put a comment on it. Put a space before and after typing a comment declaration.","keywords":"","version":"Next"},{"title":"Architecture","type":0,"sectionRef":"#","url":"/Oxomo-Coding-Conventions/docs/architecture","content":"","keywords":"","version":"Next"},{"title":"File Structure​","type":1,"pageTitle":"Architecture","url":"/Oxomo-Coding-Conventions/docs/architecture#file-structure","content":" Here is the recommended file structure:  . └── Project/ ├── ReplicatedFirst/ │ ├── Scripts │ └── Modules ├── ServerScriptService/ │ ├── Scripts │ ├── Modules │ └── Data ├── ReplicatedStorage/ │ ├── Modules/ │ │ └── Packages │ ├── Data │ ├── Assets │ └── Remotes └── ServerStorage/ └── Assets   ","version":"Next","tagName":"h2"},{"title":"ReplicatedFirst​","type":1,"pageTitle":"Architecture","url":"/Oxomo-Coding-Conventions/docs/architecture#replicatedfirst","content":" Any local scripts should go under Scripts, and any client-specific modules should go under Modules. An example of a client-specific module would be an interface component.  ","version":"Next","tagName":"h3"},{"title":"ServerScriptService​","type":1,"pageTitle":"Architecture","url":"/Oxomo-Coding-Conventions/docs/architecture#serverscriptservice","content":" Any server scripts should go under Scripts, and any server-specific modules should go under Modules. An example of a server-specific module would be a datastore wrapper.  ","version":"Next","tagName":"h3"},{"title":"ReplicatedStorage​","type":1,"pageTitle":"Architecture","url":"/Oxomo-Coding-Conventions/docs/architecture#replicatedstorage","content":" Store any common/shared modules in Modules (for example, utility modules). Packages is a folder of packages imported by a package manager, such as Wally (and belongs under Modules). Data is used to store modules or other data that is constant (for example, game config). Assets is used to store non-code instances that is used by client or server. Remotes is exclusively for remote events and remote functions.  ","version":"Next","tagName":"h3"},{"title":"ServerStorage​","type":1,"pageTitle":"Architecture","url":"/Oxomo-Coding-Conventions/docs/architecture#serverstorage","content":" Store any server-specific assets in Assets. For example, you would store maps here.  ","version":"Next","tagName":"h3"},{"title":"Modularization​","type":1,"pageTitle":"Architecture","url":"/Oxomo-Coding-Conventions/docs/architecture#modularization","content":" Modularization is important to make sure that functionality is divided into isolated scopes, either through functions or modules.  Functions should be reserved for splitting functionality that is part of a larger picture in a script or module. For example, a weapon might have functions to shoot, reload, etc.  Modules are used to separate bigger things to create libraries, databases, and systems. Some examples of things that are their own modules include:  ConfigurationsUtilitiesSystemsFrameworksClassesEtc  Variable modularization is the smallest level of splitting up information into something more digestible. This is something you should eyeball, with the general rule of thumb being &quot;if it's readable, it's good”. Make sure to utilize variables for repeated information. ","version":"Next","tagName":"h2"},{"title":"OOP Format","type":0,"sectionRef":"#","url":"/Oxomo-Coding-Conventions/docs/oop-format","content":"OOP Format Follow this format for writing OOP code: local Object = {} Object.__index = Object function Object.new(foo : number, bar : string) local self = setmetatable({}, Object) -- UNSEALED TABLE!!! self.Foo = foo self.Bar = bar self:Init() return self end function Object:Init() -- Initialization self:Method() end function Object:Method() -- ... end return Object Things to note: OOP is done best with metatables__index is declared at the top, right alongside the class declaration.new makes a variable of the top of that scope called self, which is an unsealed metatableUsing .new calls :Init() before returning self","keywords":"","version":"Next"},{"title":"Capitalization","type":0,"sectionRef":"#","url":"/Oxomo-Coding-Conventions/docs/capitalization","content":"","keywords":"","version":"Next"},{"title":"Constants​","type":1,"pageTitle":"Capitalization","url":"/Oxomo-Coding-Conventions/docs/capitalization#constants","content":" Constants, which are variables that are declared once at the top of the script and never change, are always upper case. In this case, only do this casing if the variable is in the root part of the script towards the top, not if it's in another function.  local MY_CONSTANT = 10 -- Constant local MyVariable = 10 -- Not constant MyVariable = 20   ","version":"Next","tagName":"h2"},{"title":"Arguments and parameters​","type":1,"pageTitle":"Capitalization","url":"/Oxomo-Coding-Conventions/docs/capitalization#arguments-and-parameters","content":" Arguments and parameters should be in camel case. Arguments are parameters are declared as variables that are passed by something into a more specific scope. Below are two examples of this.  Example in for loop:  for index : number, value : any in MyTable do local ExampleVariable = value --... end   Example in function:  local function MyFunction(firstArgument : number, secondArgument : string) local ExampleVariable = secondArgument end   ","version":"Next","tagName":"h2"},{"title":"OOP class-wide functions​","type":1,"pageTitle":"Capitalization","url":"/Oxomo-Coding-Conventions/docs/capitalization#oop-class-wide-functions","content":" When programming in OOP format, all OOP methods (e.g. object:Destroy()) are named in pascal case. However, OOP class functions, such as constructors (e.g. object.new()), are always done in camel case.  function object.new(...) -- Class-wide function return --... end function object:Method() -- Object method --... end   ","version":"Next","tagName":"h2"},{"title":"Configuration​","type":1,"pageTitle":"Capitalization","url":"/Oxomo-Coding-Conventions/docs/capitalization#configuration","content":" Configuration refers to tables or other userdata that act like constants shared across a project. Indexes in these config files are still in pascal case.  local SETTINGS = { Setting0 = &quot;&quot;, Setting1 = &quot;&quot;, --... }   ","version":"Next","tagName":"h2"},{"title":"Keys and actions​","type":1,"pageTitle":"Capitalization","url":"/Oxomo-Coding-Conventions/docs/capitalization#keys-and-actions","content":" A key or action would refer to something like a string sent to a function that changes behavior. In a case like this, all keys are still pascal case.  For example:  local function DoAction(actionType : string) if actionType == &quot;Foo&quot; then -- ... elseif actionType == &quot;Bar&quot; then -- ... end end DoAction(&quot;Foo&quot;)  ","version":"Next","tagName":"h2"},{"title":"Userdata Naming","type":0,"sectionRef":"#","url":"/Oxomo-Coding-Conventions/docs/userdata-naming","content":"","keywords":"","version":"Next"},{"title":"Variables​","type":1,"pageTitle":"Userdata Naming","url":"/Oxomo-Coding-Conventions/docs/userdata-naming#variables","content":" Bear in mind the following rules when deciding a name for any variables:  Do not abbreviate or truncate variable or function names from their context. Names should make sense, and should not require or provoke thought into what it actually is used for. For example, player is much better than plr, and even better than p. More verbose names is usually better.Booleans can only be true or false. As such, they should be named as if they were yes or no questions. “isAlive” sounds like a yes or no question, but “alive” does not.Names should be kept in positive form, meaning that they clarify an activity or state. Examples: Rename isDead to isAlive.Rename isNotShooting to isShootingRename isIdle to isMovingRename disallowedToDoThing to allowedToDoThingAnd etc... If the not keyword is used to negate a variable more often than not and scales that way, consider renaming the variable to the inverse.Variables should be descriptive and verbose enough to describe a purpose and state.Do not reuse variable names in shared scopes (or in other words, don't shadow variable names).  Bad example:  local CONFIG = {s = 5} local plrs = game:GetService(&quot;Players&quot;) local repstore = game:GetService(&quot;ReplicatedStorage&quot;) local pks = repstore:WaitForChild(&quot;Packages&quot;) local seam = require(pks.Seam) local n = seam.New local s = seam.Spring local plr = plrs.LocalPlayer local gui = plr.PlayerGui   Good example:  local CONFIG = {Speed = 5} local PlayersService = game:GetService(&quot;Players&quot;) local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local Packages = ReplicatedStorage:WaitForChild(&quot;Packages&quot;) local Seam = require(Packages.Seam) local New = Seam.New local Spring = Seam.Spring local Player = PlayersService.LocalPlayer local PlayerGui = Player.PlayerGui   warning The number one counter-argument to keeping consistent styling and good naming is &quot;already knowing what everything does&quot;. That does not cut it. Whether you are working by yourself or with others, at some point in the future the code will need to be iterated upon, and in order to do so there should not be time wasted asking &quot;what does everything do?”  ","version":"Next","tagName":"h2"},{"title":"Functions​","type":1,"pageTitle":"Userdata Naming","url":"/Oxomo-Coding-Conventions/docs/userdata-naming#functions","content":" Like variables, functions need solid names as well. Bear the following in mind:  Functions, when called, happen in the moment as an event. As such, they must be named as if they are in present verb form. Examples: Change allChildren() to getAllChildren() as this clarifies that the function is a &quot;getter&quot; method.Change playerMovement() to movePlayer() as this implies the userdata a call to action rather than a state. Functions should clarify what data is processed and how it is processed. To do so, include terms such as the type of data, the action, etc in the naming. Examples: Change drink() to consumeDrink(), since &quot;Drink&quot; can also represent an object, while &quot;Consume&quot; is always a call to action.  The general rule of thumb is to include as much description in a function name as possible without needing the use of comments or documentation. ","version":"Next","tagName":"h2"},{"title":"Juxtaposition","type":0,"sectionRef":"#","url":"/Oxomo-Coding-Conventions/docs/juxtaposition","content":"Juxtaposition When programming, it's important to make sure that similar things are in similar places in a script, that way other programmers know where to find what they need. When possible, your code must have data organized in this order: Class declaration (when applicable)TypesConstantsServicesImportsTypes extendedConstants extendedVariablesLocal functionsClass functions (when applicable)Class object methods (when applicable) info Juxtaposition is extremely important for consistency and readability, since it allows developers to quickly glance at a part of the code they assume will have the information they need. Types, constants, services, imports, types extended, constants extended, and variables all are separated into sections by whitespace and have a comment of each section saying what it is. &quot;Extended&quot; sections only should exist if they need something from imports or something else. Below is an example script showing proper juxtaposition and comments: local Class = {} Class.__index = Class -- Types type Dictionary = {[string] : any} -- Constants local CONSTANT_A = &quot;Hello,&quot; local CONSTANT_B = &quot;World! -- Services local PlayersService = game:GetService(&quot;Players&quot;) local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) -- Imports local Common = ReplicatedStorage.Common local Packages = Common.Packages local ModuleA = require(path.to.module) local ModuleB = require(path.to.module) -- Types extended type SpecialTypeArray = {ModuleA.SpecialType} -- Constants extended local OTHER_CONSTANT = ModuleB.SomeSetting -- Variables local ThingThatChanges = 0 local function ChangeThing() ThingThatChanges = 1 end function Class.new() return --... end function Class:Method() return --... end return Class ","keywords":"","version":"Next"}],"options":{"id":"default"}}